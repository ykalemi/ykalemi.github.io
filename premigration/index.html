<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Мигрируй вчера</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/vs.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal slide">
			<div class="footer">
							NAUMEN, Калеми Юрий
			</div>
			<div class="slides">
				<section>
					<h2>Мигрируй вчера</h2>
					<p>Миграции данных в продуктовой разработке</p>
					<img data-src="img/petr.jpg" style="border:0"/>
				</section>
				<section>
					<h2>Naumen Contact Center</h2>
					<ul>
						<li>Сервисная архитектура (~20 сервисов)</li>
						<li>Несколько сервисов работают с БД</li>
						<li>PostgreSql / Oracle</li>
						<li>Разные сервисы - разные БД (теоретически)</li>
					</ul>
					<aside class="notes">
						Как выглядит наш продукт?
						Contact Center - сервисная архитектура
						Поддерживаются PostgreSql и Oracle
						Разные сервисы могут хранить данные в разных БД
					</aside>
				</section>
				<section>
					<h2>PMS</h2>
					<ul>
						<li>Система управления проектами (PMS)</li>
						<li>Монолитное веб-приложение, Java</li>
						<li>Собственный механизм миграций</li>
						<li> &gt; 300 таблиц в PostgreSQL/Oracle</li>
					</ul>
				</section>
				<section>
					<h2>NCC</h2>
					<ul>
						<li>Тиражируемый продукт</li>
						<li>NCC установлен на инфраструктуре клиентов (On Premise)</li>
						<li>Иногда нет доступа</li>
						<li>Мажорные релизы - раз в год/полгода</li>
						<li>Минорные - каждые две недели</li>
						<li>Мы мигрируем данные</li>
					</ul>
				</section>
				<section>
					<h3>Проблема бизнеса - длинные релизы</h3>
					<ul>
						<li>Долгая доставка</li>
						<li>Нет обратной связи</li>
						<li>Нет повторных продаж</li>
					</ul>
				</section>
				<section>
					<h3>Требования бизнеса</h3>
					<ul>
						<li>Короткие релизы</li>
						<li>Минимальный простой</li>
						<li>Понимание прогресса обновления</li>
						<li>Сократить трудозатраты</li>
						<li>Возможность быстрого отката</li>
					</ul>
				</section>
				<section>
					<h3>Формулировка проблемы</h3>
					<ul>
						<li>Короткие релизы -></li>
						<li>Релизов в год больше -></li>
						<li>Столько версий невозможно поддерживать -></li>
						<li>Клиентов надо обновлять часто -></li>
						<li>3-4 обновления в год для клиента -></li>
						<li>300-400 обновлений для нас</li>
					</ul>
					<aside class="notes">
						Мы (вендор) хотим осуществить переход к более коротким релизам. Значит, релизов
						будет больше, а так как поддерживать большое количество версий невозможно,
						то хочется говорить: «дефект исправлен в следующей версии». Т.е. минорное
						обновление будет не 12.3.52 → 12.3.54, а 12.3 → 12.4. Таких обновлений для одного
						клиента может быть 3-4 в год. Если клиентов около 100, то количество обновлений,
						которые мы должны произвести в год - равно количеству дней.
						Кратко: мы хотим обновлять всех клиентов часто (=много обновлений), но клиенты и инженеры обновлений боятся
					</aside>
				</section>
				<section>
					<h2>Пример</h2>
					<img data-src="img/meta.png" style="border:0" width="60%"/><br/>
					<img data-src="img/newcols.png" style="border:0" width="60%"/>
				</section>
				<section>
					<h3>Как выглядят обновления сейчас</h3>
						<img data-src="img/migr.svg" width="100%"  style="border:0"/>
                </section>
				<section>
					<h3>Что может пойти не так</h3>
					<img data-src="img/long.svg" width="100%"  style="border:0"/>
					<aside class="notes">
						<li>Миграция данных выполняется слишком долго</li>
						<li>Не ясен прогресс миграции</li>
					</aside>
				</section>
				<section>
					<h3>Что может пойти не так</h3>
					<img data-src="img/error.svg" width="100%"  style="border:0"/>
					<aside class="notes">
						<li>Сломался один из скриптов миграции</li>
						<li>Инженер не знает как преодолеть ошибку</li>
						<li>Успешная миграция - не гарантия успешного старта</li>
						<li>Нет бекапа - нет отката</li>
					</aside>
				</section>
				<section>
					<h2>Мировой опыт</h2>
					<aside class="notes">Какие вообще есть мировые практики доставки новых версий продукта с минимальным простоем?
						В основном, все, конечно, решают только амбициозную задачу - обновление с нулевым простоем
						(ну, или только про такие задачи рассказывают в статьях и на конференциях).
						Давайте посмотрим на решение, и чему мы можем из него научиться.
					</aside>
				</section>
				<section>
					<h3>Blue Green Deployment</h3>
					<img data-src="img/green.svg" width="100%"  style="border:0"/>
					<aside class="notes">Самый простой и самый распространенный способ доставки нового релиза без прерывания обсуживания.
Есть два идентичных production-окружения. Синее и зелёное.
В каждый момент времени только одно из них активно. Например, синее.
При выпуске нового релиза на зеленом окружении собирается и тестируется новая версия приложения.
Как только все тесты прошли, маршрутизатор переключается на зеленое окружение, и все запросы теперь идут к нему.

Очень простая возможность отката изменений: если что-то пошло не так, то переключаем маршрутизатор обратно на синее окружение.
После успешного обновления синее окружение очищается и становится площадкой для следующего релиза.
Таким образом дополнительно при каждом обновлении тестируется горячее резервирование.
					</aside>
				</section>
				<section>
					<h3>Blue Green Deployment</h3>
					<img data-src="img/blue.svg" width="100%"  style="border:0"/>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Blue Green для БД</h3>
					<img data-src="img/bg_migr.svg" width="100%"  style="border:0"/>
					<aside class="notes">
					Меняем схему для поддержки v1 и v2
					Устанавливаем приложение v2
					После успешного обновления - удаляем поддержку v1


					Меняем схему таким образом, чтобы обе версии приложения могли работать с этой схемой
					Устанавливаем новую версию приложения
					Когда обновление считается успешным - удаляем “остатки” старой схемы
					Звучит как-то слишком просто. Давайте взглянем на это конкретнее.


						1. Добавляем новые колонки Name и Surname
						2. Приложение v2 умеет читать из всех трёх колонок и возвращает всегда корректные данные.
							Пишет сразу в обоих форматах, так как иначе v1 не будет работать.
						3. В фоне есть какой-то процесс миграции, который переводит данные из формата v1 в формат v2
						4. Как только признаём, что миграция успешна - можно перестать писать данные в формате v1
							(это может быть переключение какого-то конфига или новая версия приложения v3).
							С этого момента нет отката на старую версию приложения.
						5. Удаляем колонку Fullname

						С удалением колонки могут быть некоторые проблемы, если вы используете ORM - колонку можно будет
						удалить только в той версии, где она уже не задействована в маппинге. Т.е. для удаления
						надо выпускать отдельную версию приложения.
					</aside>
				</section>
				<section>
					<h3>Особенности</h3>
					<ul>
						<li>Изменение схемы во время работы</li>
						<li>Изменение схемы != Обновление приложения</li>
						<li>Обратная совместимость - автоматически</li>
						<li>Простой откат - автоматически</li>
					</ul>
					<aside class="notes">
						Что можно отметить, чему можно научиться?
						1. Изменение схемы происходит на “живом” приложении. Так живут многие компании, значит во многих случаях это возможно.
						2. Разделяем изменение схемы и обновление приложений. При старте приложения никакой миграции/изменения схемы не происходит. Тогда старт - быстрый.
						3. Во-первых, изменения схемы не должны нарушать обратную совместимость. В нашем текущем подходе мы бы просто удалили одну колонку,
							создали две другие и помигрировали данные. Но если у нас одновременно работают два приложения, то нельзя удалять колонку,
							так как она используется старой версией приложения (как именно прийти в таким изменениям, не ломающим обратную совместимость - поговорим дальше).
						4. Во-вторых, так как мы не нарушаем обратную совместимость, то у нас автоматически появляется простой способ отката -
							мы не изменяли старые данные вообще, они не могут испортиться в результате миграции.
						5. Возможность отката зависит также от того, как мы реализуем переход на версию v2. Если версия v2 может писать данные
							в обоих форматах, то даже после продолжительной работы на этой версии мы всё ещё можем остановить v2
							и просто запустить v1 - нам не нужно никакое восстановление из бэкапа.
					</aside>
				</section>
				<section>
					<h3>Проблемы</h3>
					<ul>
						<li>3! версии приложения для одного обновления</li>
						<li>+ 2 изменения схемы</li>
						<br>
						<li>Как выпускать такие релизы?</li>
						<li>Как обновлять десятки/сотни клиентов?</li>
					</ul>
					<aside class="notes">
						Для одного обновления нужно две или даже три версии приложения (v2 и v3) и два изменения схемы БД.
						Это работает в условиях сервиса, но как выпускать по две версии за один релиз? Как выполнять такое обновление у десятков клиентов?
					</aside>
				</section>
				<section>
					<h2>Миграция продукта</h2>
					<aside class="notes">
						Ок, давайте вернёмся к нашим баранам, т.е. нашему процессу, и попытаемся уменьшить количество обновлений.
					</aside>
				</section>
				<section>
					<h3>Идея #1: Фоновые миграции</h3>
					<img data-src="img/background.svg" width="100%"  style="border:0"/>
					<aside class="notes">
						Применим все прелести Blue Green к нашему приложению и нашему процессу.
						Основная идея: На старте приложения нет миграций, только подготовка новой схемы
						(новые колонки, таблицы). Все миграции - в фоне после запуска. Приложение работает
						одновременно со старыми данными и с новыми (помигрированными), причём старые данные остаются в старых колонках без изменений.
						Под словом “работает” можно понимать или “приложение умеет читать обе версии данных,
						но пишет только в новом формате”, что проще. Или “приложение читает оба формата и
						пишет тоже в обоих форматах, чтобы был простой откат” - что намного сложнее.
					</aside>
				</section>
				<section>
					<h2>Идея #1: Фоновые миграции</h2>
					<ul>
						<li>Пока идут миграции данные есть и v1, и v2</li>
						<li>Нельзя выполнять долгие блокирующие операции с БД</li>
						<li>Нельзя ставить NotNull на старте</li>
					</ul>
					<aside class="notes">
						Фоновые миграции выполняются во время работы новой версии приложения, но сохраняя старые данные.
						Т.е. пока миграция не закончилась - часть данных только в старом формате, часть - в старом и новом.

						Есть блокирующие операции - например, надо проставить Not Null. Но его нельзя проставлять,
						пока не помигрированы все данные. Такие действия выполняются после того, как отработала фоновая
						миграция - по какой-то команде инженера/администратора в заранее оговорённое технологическое окно.
					</aside>
				</section>
				<section>
					<h2>Риски</h2>
					<ul>
						<li>Поддержка 2-х версий кода и данных</li>
						<li>Частичная неработоспособность</li>
					</ul>
					<aside class="notes">

							1. В новой версии накапливается legacy (нужно поддерживать данные двух видов,
							нужно оставлять старые механизмы и т.п.). А это означает увеличение стоимости внедрения новых фич.
							2. Если изменение очень большое - не очень ясно, как реализовать поддержку
							сразу двух версий данных. У нас был такой пример: мы переделывали маппинг объектов
							с иерархии таблиц на дискриминаторы. Как поддерживать два разных вида объектов в ORM? Создавать фиктивные классы?
							3. Списки объектов с сортировкой и фильтрацией - как они будут работать,
							если сортировка/фильтрации затрагивают мигрируемые данные?

						Самые большие риски, которые мы видим:
						Поддерживать две версии кода и две версии данных в одном приложении будет слишком дорого
						Пока работают фоновые миграции, какие-то данные находятся в разных версиях - а значит, может не работать какая-то функциональность (списки с фильтрацией)
					</aside>
				</section>
				<section>
					<h3>Идея #1: Фоновые миграции</h3>
					<h4>Нужна изоляция кода при работе с БД</h4>
					<aside class="notes">
						Для того, чтобы приложение могло читать данные в двух форматах (и, возможно, писать данные также в двух форматах),
						нужно чётко понимать, где приложение общается с базой данных. Т.е. В идеальном случае для каждого
						объекта должен быть единственный DAO, который работает с базой данных. Тогда мы можем легко локализовать
						работу с базой и поставить все нужные условия - ( if vesrion == 1 then…).
						Т.е. Нужно думать о работе с базой в том же ключе, как работают с базой микросервисы - никакой
						другой микросервис не должен знать о способе хранения данных в БД, кроме его владельца.
						В любом другом монолитном сервисе должны быть точно такие же правила.
						К сожалению, эта история пока не про нас.
					</aside>
				</section>
				<section>
					<h2>Идея #2</h2>
					<ul>
						<li>Сначала мигрируем БД</li>
						<li>Потом обновляем!</li>
					</ul>
					<aside class="notes">
						Давайте сначала мигрировать схему и данные, а только потом обновлять приложение!
					</aside>
				</section>
				<section>
					<h2>Идея #2: Предмиграции</h2>
					<img data-src="img/premigr.svg" width="100%"  style="border:0"/>
					<aside class="notes">
						Основная идея: перед обновлением на новую версию запускается мигратор,
						приложение при этом не останавливается. После окончания миграции останавливается приложение,
						запускается новая версия, которая на старте (как сейчас) домигрирует новые или изменённые данные,
						удаляет старые столбцы, выполняет какие-то блокирующие операции.
					</aside>
				</section>
				<section>
					<h3>Принципы</h3>
					<ul>
						<li>Не менять данные</li>
						<li>Не вызывать деградацию</li>
						<li>Не блокировать БД</li>
						<li>Разбить на пачки, чтобы останавливать</li>
						<li>Уметь запускаться многократно</li>
						<li>Миграции после старта - доделывают</li>
					</ul>
					<aside class="notes">
Пред-миграции выполняются во время работы старой версии приложения, поэтому не должны затрагивать старые данные, не должны
вызывать деградацию приложения. Если деградация возникает (слишком высокая нагрузка на диск/cpu/т.п.), должна быть возможность
остановить предмиграции.

  * никак не изменяем и не удаляем существующие данные
  * не выполняем блокирующих операций над БД (как минимум - блокирующих БД надолго)
  * процесс миграции должен быть разбит на пачки, для того чтобы можно было остановить этот процесс после выполнения очередной пачки (сейчас размер пачки - 1000)
  * миграции должны уметь запускаться многократно, поэтому они должны отличать новые данные от уже помигрированных (домигрировать)
  * классические миграции доделывают то, что начали предмиграции (в идеале - запускают тот же код); далее - выполняют все необходимые блокирующие операции и изменения БД
					</aside>
				</section>
				<section>
					<h3>А если данные изменились?</h3>
					<ul>
						<li>Версия данных в каждой строке</li>
						<li>Триггеры</li>
					</ul>
					<aside class="notes">
						Дальше только теория, как это можно решать:
						Хранить версию данных для каждой строки. Если мы помигрировали строку на версию v2,
						то записываем в версию v2. Если старое приложеине изменило данные, то оно записывает
						в эту строку свою версию, т.е v1. Итого, мигратор работает пока есть строки с версией v1.
						Триггеры. Перед началом работы предмигратор создаёт триггер, который в случае изменений
						в строке удалит новую версию данных/сбросит версию данных/куда-то сохранит информацию, что эту строку надо домигрировать
					</aside>
				</section>
				<section>
					<h3>Часть приложения или новый сервис?</h3>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Часть приложения или новый сервис?</h3>
					<h4>Аргументы "За часть приложения"</h4>
					<ul>
						<li>Инфраструктура проще</li>
						<li>Инженерам проще (=дешевле)</li>
						<li>Кнопка в GUI</li>
					</ul>
					<aside class="notes">
						Аргументы за часть приложения: мы не хотим усложнять инфраструктуру,
						делать жизнь инженеров более трудной (а, следовательно, увеличивать трудозатраты).
						Если предмиграции являются частью приложения, то инженеру/администратору достаточно
						зайти на специальную страницу и нажать кнопку.
					</aside>
				</section>
				<section>
					<h3>Часть приложения или новый сервис?</h3>
					<h4>Аргументы против "отдельного сервиса"</h4>
					<ul>
						<li>Для мажорного обновления нужно минорное</li>
						<li>В случае ошибки - минорное обновление</li>
						<li>Отсутствует изоляция производительности</li>
						<li>В случае проблем - рестарт приложения</li>
					</ul>
					<aside class="notes">
						Для того, чтобы в приложении версии v1 появились предмиграции, это приложение надо обновить
						на какую-то последнюю версию v1.123. Т.е. Перед мажорным обновлением обязательно должно присутствовать минорное.
						Было требование, что работа предмигратора не должна приводить к деградации производительности. Если это
						какая-то высокая утилизация CPU, то в случае отдельного сервиса - его можно запустить на другой машине.
						Если в предмиграторе есть ошибка, то для её исправления надо (а) выпустить
						новую версию всего приложения и (б) снова выполнить обновление.
						Если предмигратор завис и не отвечает, то в случае отдельного сервиса можно его просто убить.
					</aside>
				</section>
				<section>
					<h3>Отдельный сервис</h3>
					<ul>
						<li>Есть веб-интерфейс</li>
						<li>Доступен из приложения (проксируется)</li>
						<li>Для инженера/администратора: почти как часть приложения</li>
					</ul>
					<aside class="notes">
						В итоге мы решили, что предмигратор - это отдельный сервис. К тому же,
						миграции могут понадобиться для большого количества сервисов.
						И логично не писать для каждого из них предмигратор, а использовать один на всех.

						Для того, чтобы снизить неудобства инженера/администратора:
						У предмигратора есть свой веб-интерфейс, где можно увидеть предполагаемый
						список миграций. Можно их запускать/останавливать и просматривать статистику.
						Веб-интерфейс предмигратора показывается внутри веб-приложения (запросы проксируются).
						Таким образом для инженера/администратора это выглядит как часть веб-приложения.
					</aside>
				</section>
				<section>
					<h3>Как выглядит сервис?</h3>
					<ul>
						<li>Java, Spring boot</li>
						<li>Web, REST, JMX</li>
						<li>Статистика</li>
						<li>Можно остановить в процессе</li>
						<li>Можно продолжить выполнение</li>
						<li>Проверка версии мигрируемой базы</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>А что с разработчиками и тестовыми стендами?</h3>
					<ul>
						<li>Возможно обновление без предмигратора</li>
					</ul>
					<aside class="notes">
						Решение следующее: если не было запуска предмигратора, то при старте будет выполнена полноценная миграция, т.е. как и раньше.
					</aside>
				</section>
				<section>
					<h3>Будет две версии миграций?</h3>
					<ul>
						<li>В общем случае - да. Для PMS - нет</li>
						<li>PMS - состоит из модулей</li>
						<li>Модуль для миграций</li>
						<li>Его используют PMS и Предмигратор</li>
					</ul>
					<aside class="notes">
						Будет две версии миграций?
						Для предмигратора и для классических миграций?
						В общем случае (для любого абстрактного сервиса) - да.

						Но для нашего приложения у нас используется общий код миграций. Благодаря тому, что у нас модульная структура, код с миграциями выделен в отделный модуль. От которого зависит и предмигратор, и OPMS.

						При запуске “классической” миграции происходит запуск кода из этого модуля.

						В итоге мы можем быть уверены, что мы выполняем одни и те же изменения. И запуск классической миграции - это просто как очередной и последний запуск предмигратора.

					</aside>
				</section>
				<section>
					<h3>Что можно делать в базе?</h3>
					<ul>
						<li>Добавление колонки</li>
						<li>Удаление колонки (PG)</li>
						<li>Создание индекса с флагом CONCURRENTLY (PG) / ONILNE (ORA)</li>
						<li>Удаление ограничения</li>
						<li>Добавить дефолтное значение в существующую колонку</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<h4>Добавлять индекс</h4>
					<ul>
						<li>Делай CONCURRENTLY/ONLINE</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<h4>Менять тип/имя колонки</h4>
					<ul>
						<li>Создай новую колонку</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<h4>Добавлять новую колонку с дефолтным значением</h4>
					<ul>
						<li>Добавить новую колонку</li>
						<li>Добавить дефолтное значение</li>
						<li>Заполнить колонку дефолтным значением</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<p><b>Но в PostgreSQL 11 уже можно</b></p>
					<img data-src="img/postgresql.png" style="border:0"/>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<h4>Добавлять новую колонку NOT NULL</h4>
					<ul>
						<li>Создать новую таблицу</li>
						<li>Добавить NOT NULL колонку</li>
						<li>Писать в обе таблицы</li>
						<li>Скопировать данные...</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе? (PG)</h3>
					<h4>Добавлять новую колонку UNIQUE</h4>
					<ul>
						<li>Добавить колонку</li>
						<li>Добавить уникальный индекс (concurrently)</li>
						<li>Добавить ограничение на таблицу</li>
						<li>UNIQUE USING INDEX</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе? (PG)</h3>
					<h4>VACUUM FULL</h4>
					<ul><li>Используй pg_repack</li></ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>А минусы?</h3>
					<ul>
						<li>Много места в БД</li>
						<li>Нет отката после запуска</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Возможность отката</h3>
					<h4>теоретическая</h4>
					<aside class="notes">
						После того, как запущена новая версия приложения, выполняются различные изменения в схеме данных, которые могут привести к невозможности запуска старой версии.
						Самый банальный пример - удаление столбца, добавление ограничения Not Null.

						Можно договориться и не делать такие изменения на старте системы, тогда возможность отката будет сохранена. Но с тем же Not Null - не ясно, когда мы сможем его сделать? Сколько будет жить приложение без этого ограничения?

						Но после того как приложение запускается и пользователи начинают работу, они начинают записывать данные в новые таблицы и колонки. И откат не возможен, потому что данные в старых таблицах становятся неконсистентные.

						Единственный выход - писать в двух форматах. См. все предыдущие ограничения и задачи, которые стоят перед нами и нашим приложением.
						Надеюсь, мы сможем научиться работать по такой схеме.
					</aside>
				</section>
				<section>
					<h3>Сопутствующие приобретения</h3>
					<ul>
						<li>Простое тестирование миграций во время разработки</li>
						<li>Запуск на любом стенде</li>
						<li>Запуск на тестовой базе клиентов</li>
						<li>Мигрировать можно и днём</li>
					</ul>
					<aside class="notes">
						Можно тестировать на любом тестовом стенде - данные не портятся.
						Можно тестировать прямо в процессе разработки на любом тестовом стенде клиента -
						и находить проблемные данные, которые сломают миграцию. И учесть это. А также проверить примерное время выполнения.
						Если выполнять вообще все миграции через предмигратор, то не нужны тестовые миграции!
					</aside>
				</section>
				<section>
					<h3>Результат</h3>
					<ul>
						<li>Вышло несколько релизов с предмиграциями</li>
						<li>Ошибки исправляем до выпуска версии</li>
						<li>Самая долгая миграция:  14 часов</li>
						<li>Одна идёт ~14 часов, другая - 30 секунд</li>
						<li>Можем позволить себе длинные миграции</li>
						<li>Клиенты и инженеры спокойнее относятся к обновлениям</li>
					</ul>
					<aside class="notes">
						Мы выполнили предмиграцию на тестовой базе самого большого клиента.
						Нашли 2 ошибки, из-за которых миграции не работали. Исправили их ещё до выпуска версии.
						Миграции проходят примерно 14 часов (без нагрузки на базу, конечно). У нас всего две миграции: одна шла 14 часов, другая - 30 секунд.
					</aside>
				</section>

				<section>
					<h2>Конец</h2>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
				// Shows the slide number using default formatting
				slideNumber: true,
				controls: false,
				center: true,
				transition: 'slide',
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
